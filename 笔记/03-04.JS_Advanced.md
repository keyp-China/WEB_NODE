# 编程思想
## 面向过程编程 POP
面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了
* 优缺点
  * 优点：性能比面向对象高，步骤练习紧密
  * 缺点：不好维护，不易多次使用及扩展
## 面向对象编程 OOP
面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作
优缺点
- 优点：易维护，可复用，可扩展，灵活性高
- 缺点：性能没有面向过程高
**面向对象的思维特点:**
	​	 1.抽取对象共用的属性和方法(封装)形成一个类(模板)
	​	 2.对类进行实例化, 获取类的对象
### 三大特性
* **封装性**
* **继承性**
* **多态性**
# ES6中的类和对象
## class类
`在ES6中新增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象。【构造函数实例化对象】`
- **类**抽象了对象的公共部分，它泛指某一类（class）
- **对象**特指某一个，通过类实例化一个具体的对象
```js
//创建类
class Person{
    //定义构造方法
    constructor(name,age){
        //定义属性
        this.name=name;
        this.age=age;
    }
    //定义普通方法
    say(){
        console.log("说话");
    }
}
```
## class类的继承
* **extends**
* **super**
  * **总结：super调用父类的属性和方法，那么查找属性和方法的原则就近原则**
```js
//父类
class Father {
    constructor(name){
        this.name=name;
    }
    say(){}
}
//子类继承父类
class Son extends Father{
    constructor(name,age){
        //调用父类构造方法
        super(name);
        this.age=age;
    }
    say(){
        //调用父类普通方法
        super.say();
    } 
}
```
## 三个注意点
* 在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象.
* 类里面的共有属性和方法一定要加this使用
* 类里面的this指向问题.
  * constructor 里面的this指向实例对象,
  * 方法里面的this 指向这个方法的调用者，谁调用指向谁
# ES5中的构造函数
` 在典型的OOP的语言中（如Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在ES6之前，JS中并没用引入类的概念。` 
 `ES6，全称ECMAScript6.0 ，2015.06 发版。但是目前浏览器的JavaScript是ES5版本，大多数高版本的浏览器也支持ES6，不过只实现了ES6的部分特性和功能。`
 `在ES6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。 `
## 定义构造函数
构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。
```js
//定义构造函数
function Person(name){
    this.name=name;
}
//实例化一个对象
var person = new Person("zs");
```
* 在JS中，使用构造函数时要注意以下两点
  1. 构造函数用于创建某一类对象，其首字母要大写
  2. 构造函数要和new 一起使用才有意义
* **new在执行时会做四件事情**
  1. 在内存中创建一个新的空对象。
  2. 让this指向这个新的对象。
  3. 执行构造函数里面的代码，给这个新对象添加属性和方法。
  4. 返回这个新对象（所以构造函数里面不需要return）。
## 静态成员和实例成员
JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。
- 静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问，不需要实例化对象。
- 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问，需要实例化对象。
## 原型对象 prototype
* 原型对象：就是构造函数的一个属性，这个属性是一个对象，我们称呼这个属性prototype 为原型对象。
* 每一个构造函数都有一个prototype属性
* 作用：是为了共享方法，从而达到节省内存
```js
function Person(name){
    this.name=name;
}
//把方法放入原型对象中
//1.第一种方式
Person.prototype.sing=function(){}
//2、第二种方式
Person.prototype = {
    sing:function(){},
    say:function(){},
    constructor:Person
}
```
**总结：所有的公共属性写到构造函数里面，所有的公共方法写到原型对象里面**
## 对象原型 --proto--（下划线）
**总结：每一个对象都有一个对象原型属性，作用是指向原型对象prototype**
`注意：__proto__是一个非标准属性，不可以拿来赋值或者设置【只读属性】`
* __proto__对象原型和原型对象prototype是等价的

- __proto__对象原型的意义就在于为对象的查找机制提供一个方向，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype

## 构造函数constructor

**总结：constructor  主要作用可以指回原来的构造函数**

在原型对象和对象原型中都有一个属性constructor

## 构造函数、实例对象、原型对象三者之间的关系
1. new 构造函数() ==> 实例对象           实例对象.proto.constructor ==> 构造函数
2. 构造函数.prototype ==> 原型对象   原型对象.constructor ==> 构造函数
3. 实例对象.proto ==> 原型对象
* prototype：原型对象，每一个构造函数都有这个属性
* proto：对象原型，每一个实例对象都有这个属性，这个属性的作用就是指向prototype
* constructor：构造函数，prototype，proto都有这个属性，这个属性的作用指回构造函数

## 原型链

* 作用；提供一个成员的查找机制，或者查找规则

<img src="./images/原型链.jpg">